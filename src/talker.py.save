#!/usr/bin/env python
from __future__ import print_function
import roslib
roslib.load_manifest('lane_detection')
import rospy
import sys
from std_msgs.msg import String
import cv2
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from picamera import PiCamera
from picamera.array import PiRGBArray
import time
import numpy as np
import RPi.GPIO as GPIO

def detect(img):
	# Gaussian Filter to remove noise
	img = cv2.medianBlur(img,5)
	gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

	# print img.shape = (200,350,3)

	# ROI
	roi_mask = np.zeros(img.shape,dtype=np.uint8)
	roi_mask[100:200,0:350] = 255
	street = cv2.bitwise_and(img,roi_mask)

	stop_roi_mask = np.zeros(gray.shape,dtype=np.uint8)
	stop_roi_mask[100:200,50:300] = 255

	right_roi_mask = np.zeros(gray.shape,dtype=np.uint8)
	right_roi_mask[100:200,175:350] = 255

	left_roi_mask = np.zeros(gray.shape,dtype=np.uint8)
	left_roi_mask[100:200,0:175] = 255

	# define range of color in HSV
	hsv = cv2.cvtColor(street,cv2.COLOR_BGR2HSV)

	sensitivity = 120 # range of sensitivity=[90,120]
	lower_white = np.array([0,0,255-sensitivity])
	upper_white = np.array([255,sensitivity,255])

	white_mask = cv2.inRange(hsv,lower_white,upper_white)
	white_mask = cv2.erode(white_mask, None, iterations=2)
	white_mask = cv2.dilate(white_mask, None, iterations=2)
	
	lower_red = np.array([165,100,100])
	upper_red = np.array([180,255,255])

	red_mask = cv2.inRange(hsv,lower_red,upper_red)
	red_mask = cv2.erode(red_mask, None, iterations=2)
	red_mask = cv2.dilate(red_mask, None, iterations=2)

	# mask AND original img
	hsvthresh = cv2.bitwise_and(street,street,mask=white_mask)
	redhsvthresh = cv2.bitwise_and(street,street,mask=red_mask)

	# Canny Edge Detection 
	edges = cv2.Canny(hsvthresh,100,200)
	right_edges = cv2.bitwise_and(edges,right_roi_mask)
	left_edges = cv2.bitwise_and(edges,left_roi_mask)

	red_edges = cv2.Canny(redhsvthresh,100,200)
	red_edges = cv2.bitwise_and(red_edges,stop_roi_mask)

	# Standard Hough Transform
	right_lines = cv2.HoughLines(right_edges,1,np.pi/180,60)
	left_lines = cv2.HoughLines(left_edges,1,np.pi/180,60)
	red_lines = cv2.HoughLines(red_edges,1,np.pi/180,40)
	
	# Draw right lane
	if right_lines is not None:
		right_lines = np.array(right_lines[0])
		for rho, theta in right_lines:
                        a=np.cos(theta)
                        b=np.sin(theta)
                        x0,y0=a*rho,b*rho
                        pt1=(int(x0+1000*(-b)),int(y0+1000*(a)))
                        pt2=(int(x0-1000*(-b)),int(y0-1000*(a)))
                        cv2.line(img,pt1,pt2,(255,0,0),2)
	
	# Draw left lane
	if left_lines is not None:
		left_lines = np.array(left_lines[0])
		for rho, theta in left_lines:
                        a=np.cos(theta)
                        b=np.sin(theta)
                        x0,y0=a*rho,b*rho
                        pt1=(int(x0+1000*(-b)),int(y0+1000*(a)))
                        pt2=(int(x0-1000*(-b)),int(y0-1000*(a)))
                        cv2.line(img,pt1,pt2,(0,255,0),2)


	# Draw STOP line
	if red_lines is not None:
		red_lines = np.array(red_lines[0])
		for rho, theta in red_lines:
                        a=np.cos(theta)
                        b=np.sin(theta)
                        x0,y0=a*rho,b*rho
                        pt1=(int(x0+1000*(-b)),int(y0+1000*(a)))
                        pt2=(int(x0-1000*(-b)),int(y0-1000*(a)))
                        cv2.line(img,pt1,pt2,(0,0,255),2)

	if red_lines is not None:
		time.sleep(0.5)
		return "stop" # STOP

	if right_lines is not None:
		if left_lines is not None:
			return "a" # Go straight
		elif left_lines is None:
			return "s" # Turn left
	elif right_lines is None:
		if left_lines is not None:
			return "d" # Turn right
		elif left_lines is None:
			return "x" # No line found

	return "x"

def talker():
	pub = rospy.Publisher('lane_detection', String, queue_size=10)
	rospy.init_node('talker',anonymous=True)

	camera = PiCamera() # Raspberry Pi Camera
	camera.resolution = (350,200)
	camera.framerate = 50
	camera.contrast = 30
	camera.saturation = 20
	camera.brightness = 40
	camera.sharpness = 0
	camera.start_preview()
	time.sleep(1)
	rawCapture = PiRGBArray(camera)
	
	rate = rospy.Rate(30) # publisher frequency
	bridge = CvBridge()

	while not rospy.is_shutdown():
		camera.capture(rawCapture, format='bgr', use_video_port=True)
		rospy.loginfo("Sending an Image Message")
#		try:
		info = detect(rawCapture.array)
#		except Exception:
#			pass

		pub.publish(info)
		rawCapture.truncate(0)
#		rate.sleep()

if __name__ == '__main__':
	try:
		talker()
	except rospy.ROSInterruptException:
		pass
